<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>reveal.js</title>

		<link rel="stylesheet" href="css/reset.css">
		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css">
		<link rel="stylesheet" href="css/mystyle.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/monokai.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<h1>Canvas</h1>
					<aside class="notes">
						Hello. Today I want to talk about such an exciting element as canvas.First of all, what is it all canvas?
					</aside>
				</section>
				<section>
					<h2>What is HTML Canvas?</h2>					
					<p>A canvas is a rectangular area on an HTML page. By default, a canvas has no border and no content.					
					</p>					
					<p>The <span class="green">default size</span> of the canvas is <span class="number-red">300</span> pixels × 
						<span class="number-red">150</span> pixels (width × height). 
					</p>
					<pre>
						<code><canvas id="tutorial" width="250" height="100"></canvas></code>
					</pre>
					<aside class="notes">
						The canvas element is part of HTML5 and used to draw graphics, on the fly. 
						But it is only a container for graphics. You must use JavaScript to actually draw the graphics.						
						The canvas element has only two attributes,
						width and height.
						The default size of the canvas is 300 pixels in width and 150 pixels in height. 						
						And it is always a good idea to supply an id because this makes it much easier to identify it in a script.
					</aside>
				</section>
				<section>
					<h2>What HTML5 Canvas Is Used For?</h2>
					<ul>
						<li>Dynamic graphics</li>
						<li>Online and offline games</li>
						<li>Animations</li>
						<li>Interactive video and audio</li>
					</ul>
					<aside class="notes">
						Тhe next slide is called "What HTML5 Canvas Is Used For?". As I said earlier canvas is an HTML element which
						can be used for rendering graphs, game graphics, combine photos, create animations, 
						online and offline games, art, or other visual images on the fly.
					</aside>
				</section>
				<section>
					<h2>History</h2>
					<p>Canvas was initially introduced by <span class="green">Apple</span> for use inside their own Mac OS X WebKit 
						component in <span class="red">2004</span>, powering applications like Dashboard widgets and the Safari browser. </p>
					<p>Later, in <span class="red">2005</span> it was adopted in version 1.8 of Gecko browsers, and Opera in 
						<span class="red">2006</span>, and 
						standardized by the Web Hypertext Application Technology Working Group on new proposed 
						specifications for next generation web technologies.
					</p>
					<aside class="notes">
						Canvas was initially introduced by Apple for use inside their own Mac OS X WebKit 
						component in 2004, powering applications like Dashboard widgets and the Safari browser.
						Later, in 2005 it was adopted in version 1.8 of Gecko browsers, and Opera in 2006.						
					</aside>
				</section>				
				<section>
					<h2>Browser Support</h2>					
					<table class="browser-support">
						<caption>The numbers in the table specify the first browser version that fully supports the element.</caption>
						<tr>
							<th>Element</th>
							<th>Chrome</th>
							<th>Internet Explorer</th>
							<th>Firefox</th>
							<th>Safari</th>
							<th>Opera</th>
						</tr>
						<tr>
							<td>canvas</td>
							<td>4.0</td>
							<td>9.0</td>
							<td>2.0</td>
							<td>3.1</td>
							<td>9.0</td>
						</tr>
					</table>
					<aside class="notes">
						Today this element is supported by the current versions of Mozilla Firefox, 
						Google Chrome, Internet Explorer, Safari, Opera and Microsoft Edge.
					</aside>	
				</section>
				<section>
					<h2> The types of canvas context:</h2>
					<ul>
						<li>"2d"</li>
						<li>"webgl"</li>
						<li>"webgl2"</li>
						<li>"bitmaprenderer"</li>
					</ul>							
					<pre>
						<code>var canvas = document.getElementById('tutorial');</code>
						<code>var ctx = canvas.getContext('2d');</code>
					</pre>
					<aside class="notes">
						The canvas element creates a fixed-size drawing surface that exposes one
						or more rendering contexts, which are used to create and manipulate the content shown.
						2D rendering context is used for 2D graphics. Other contexts may provide different types of rendering;
						for example, WebGL uses a 3D context.
						The canvas element has a method called getContext(), used to obtain the
						rendering context and its drawing functions.
					</aside>
				</section>
				<section>
					<h2>The canvas grid</h2>
					<p>The origin of canvas grid is positioned in the top left corner at coordinate (0,0). 
					</p>
					<img src="images/Canvas_default_grid.png" alt="Canvas default grid" width="250" height="250">
					<aside class="notes">
						The origin of canvas grid is positioned in the top left corner at coordinate (0,0). All elements are placed relative to this origin.
					 	So the position of the top left corner of the blue square becomes x pixels from the left and y pixels from the top.
					</aside>
				</section>
				<section>
					<h2>Drawing rectangles</h2>
					<p>There are three functions that draw rectangles on the canvas:</p>
					<ul>
						<li><span class="green">fillRect(x, y, width, height)</span> - Draws a filled rectangle.</li>
						<li><span class="green">strokeRect(x, y, width, height)</span> - Draws a rectangular outline.</li>
						<li><span class="green">clearRect(x, y, width, height)</span> - Clears the specified rectangular area, making it fully transparent.</li>
					</ul>
					<aside class="notes">
						Unlike SVG, canvas only supports one primitive shape: rectangles. All other shapes must be created by combining one or more paths,
						lists of points connected by lines. 
						First let's look at the rectangle. There are three functions that draw rectangles on the canvas: fillRect, strokeRect and
						clearRect. Each of these three functions takes the same parameters. x and y specify the position on the canvas
						of the top-left corner of the rectangle. Width and height provide the rectangle's size.
					</aside>
				</section>
				<section>
					<h2>Drawing paths</h2>
					<ul>
						<li><span class="green">beginPath()</span> - Creates a new path.</li>
						<li><span class="green">closePath()</span> - Adds a straight line to the path, going to the start of the current sub-path.</li>
						<li><span class="green">stroke()</span> - Draws the shape by stroking its outline.</li>
						<li><span class="green">fill()</span> - Draws a solid shape by filling the path's content area.</li>						
					</ul>
					<aside class="notes">
						The only other primitive shapes are paths. A path is a list of points, connected by segments of lines that
						can be of different shapes, of different width and of different color. To make shapes using paths
						takes some extra steps:
						First, you create the path.
						Then you use drawing commands to draw into the path.
						Once the path has been created, you can stroke or fill the path to render it.
						Here are the functions used to perform these steps: beginPath, closePath, stroke and fill.
					</aside>
				</section>
				<section>
					<h4>Drawing a triangle</h4>					
					<pre>
						<code>
function draw() {
	var canvas = document.getElementById('canvas');
	if (canvas.getContext) {
		var ctx = canvas.getContext('2d');							  
		ctx.beginPath();
		ctx.moveTo(75, 50);
		ctx.lineTo(100, 75);
		ctx.lineTo(100, 25);
		ctx.fill();
	}
}</code>								
					</pre>
					<img src="images/triangle.png" alt="Black triangle">
					<aside class="notes">
						For example, the code for drawing a triangle would look something like this.
					</aside>
				</section>
				<section>
					<h2>Moving the pen and lines</h2>
					<ul>
						<li><span class="green">moveTo(x, y)</span> - Moves the pen to the coordinates specified by x and y.</li>
						<li><span class="green">lineTo(x, y)</span> - Draws a line from the current drawing position to the position specified by x and y.</li>										
					</ul>
					<aside class="notes">
						One very useful function, which doesn't actually draw anything but becomes part of the path list described above,
						is the moveTo() function.
						You can probably best think of this as lifting a pen or pencil from one spot on a piece of paper and placing 
						it on the next.
						For drawing straight lines, use the lineTo() method.
					</aside>
				</section>
				<section>
					<h2>Arcs</h2>
					<ul>
						<li><span class="green">arc(x, y, radius, startAngle, endAngle, anticlockwise)</span></li>
						<li><span class="green">arcTo(x1, y1, x2, y2, radius)</span></li>
					</ul>
					<p> Angles in the arc function are measured in <span class="red">radians</span>, not degrees. To convert degrees to
						 radians you can use the following JavaScript expression: 
					</p>
					<p><span class="green">radians = (Math.PI/180)*degrees</span></p>
					<aside class="notes">
						To draw arcs or circles, we use the arc() or arcTo() methods.
						Angles in the arc function are measured in radians, not degrees. To convert degrees to
						radians you can use the following JavaScript expression.
					</aside>
				</section>
				<section>
					<h4>Example. Draw a Circle</h4>
					<pre>
						<code>
	var c = document.getElementById("myCanvas");
	var ctx = c.getContext("2d");
	ctx.beginPath();
	ctx.arc(95, 50, 40, 0, 2 * Math.PI);
	ctx.stroke();</code>
					</pre>
					<img src="images/circle.png" alt="Circle">
					<aside class="notes">
						Here's an example of how to draw a circle using canvas.
					</aside>
				</section>
				<section>
					<h2>Bezier and quadratic curves</h2>
					<ul>
						<li><span class="green"></span>quadraticCurveTo(cp1x, cp1y, x, y)</li>
						<li><span class="green"></span>bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)</li>
					</ul>
					<img src="images/Canvas_curves.png" alt="Canvas curves" width="300" height="300">
					<aside class="notes">
						The next type of paths available are Bézier curves, available in both cubic
						and quadratic varieties. These are generally used to draw complex organic shapes.
						The difference between these can best be described using the image on the slide. 
						A quadratic Bézier curve has a start and an end point (blue dots) and just one control 
						point (indicated by the red dot) while a cubic Bézier curve uses two control points.
					</aside>
				</section>
				<section>
					<h4>Example. Quadratic Bezier curves</h4>
					<pre>
						<code>
	function draw() {
		var canvas = document.getElementById('canvas');
		if (canvas.getContext) {
			var ctx = canvas.getContext('2d');
			ctx.beginPath();
			ctx.moveTo(75, 25);
			ctx.quadraticCurveTo(25, 25, 25, 62.5);
			ctx.quadraticCurveTo(25, 100, 50, 100);
			ctx.quadraticCurveTo(50, 120, 30, 125);
			ctx.quadraticCurveTo(60, 120, 65, 100);
			ctx.quadraticCurveTo(125, 100, 125, 62.5);
			ctx.quadraticCurveTo(125, 25, 75, 25);
			ctx.stroke();
			}
	}</code>
					</pre>
					<img src="images/Canvas_quadratic.png" alt="Canvas quadratic" width="120" height="90">
					<aside class="notes">
						This example uses multiple quadratic Bézier curves to render a speech balloon.
					</aside>
				</section>
				<section>
					<h2>Applying styles and colors</h2>					
					<ul>
						<li><span class="green">fillStyle = color</span> - Sets the style used when filling shapes.</li>
						<li><span class="green">strokeStyle = color</span> - Sets the style for shapes' outlines.</li>										
					</ul>
					<p>By default, the stroke and fill color are set to black.</p>
					<aside class="notes">
						If we want to apply colors to a shape, there are two important properties we can use: fillStyle and strokeStyle.
						fillStyle sets the style used when filling shapes. And strokeStyle Sets the style for shapes' outlines.
						When we set the strokeStyle or fillStyle property, the new value becomes the default for all shapes being
						drawn from then on. For every shape we want in a different color, you will need to reassign the fillStyle or 
						strokeStyle property.
					</aside>
				</section>
				<section>
					<h2>A fillStyle example</h2>
					<pre>
						<code>
function draw() {
  var ctx = document.getElementById('canvas').getContext('2d');
  for (var i = 0; i < 6; i++) {
    for (var j = 0; j < 6; j++) {
	  ctx.fillStyle = 'rgb(' + Math.floor(255 - 42.5 * i) + 
	    ', ' + Math.floor(255 - 42.5 * j) + ', 0)';
      ctx.fillRect(j * 25, i * 25, 25, 25);
    }
  }
}</code>
					</pre>
					<img src="images/Canvas_fillstyle.png" alt="Canvas fillstyle example" width="170" height="170">
					<aside class="notes">
							In this example, we will draw a grid of rectangles, each in
							a different color. Image should look like the screenshot.	
					</aside>
				</section>
				<section>
					<h2>Line styles</h2>
					<ul>
						<li><span class="green">lineWidth = value</span> - Sets the width of lines drawn in the future.</li>
						<li><span class="green">lineCap = type</span> - Sets the appearance of the ends of lines.</li>
						<li><span class="green">lineJoin = type</span> - Sets the appearance of the "corners" where lines meet.</li>
						<li><span class="green">miterLimit = value</span> -Establishes a limit on the miter when two lines join at a
							 sharp angle, to let you control how thick the junction becomes.</li>						
					</ul> 
					<aside class="notes">
						There are several properties which allow us to style lines. --->
					</aside>
				</section>
				<section>
					<ul>
						<li><span class="green">getLineDash()</span> - Returns the current line dash pattern array containing an even number of non-negative numbers.</li>
						<li><span class="green">setLineDash(segments)</span> - Sets the current line dash pattern.</li>
						<li><span class="green">lineDashOffset = value</span> - Specifies where to start a dash array on a line.</li>
					</ul>
				</section>
				<section>
					<h2>Gradients</h2>
					<ul>
						<li><span class="green">createLinearGradient(x1, y1, x2, y2)</span> - Creates a linear gradient object with a starting 
							point of (x1, y1) and an end point of (x2, y2).</li>
						<li><span class="green">createRadialGradient(x1, y1, r1, x2, y2, r2)</span> - Creates a radial gradient. The parameters represent two circles,
							 one with its center at (x1, y1) and a radius of r1, and the other with its center at (x2, y2) with a radius of r2.</li>
						<li><span class="green">gradient.addColorStop(position, color)</span> - Creates a new color stop on the gradient object.</li>
					</ul>
					<aside class="notes">
						Just like any normal drawing program, we can fill and stroke shapes using linear and radial gradients. 						
					</aside>
				</section>
				<section>
					<h2>Drawing text</h2>
					<ul>
						<li><span class="green">fillText(text, x, y [, maxWidth])</span> - Fills a given text at the given (x,y) position. 
							Optionally with a maximum width to draw.</li>
						<li><span class="green">strokeText(text, x, y [, maxWidth])</span> - Strokes a given text at the given (x,y) position.
							 Optionally with a maximum width to draw.</li>
					</ul>
					<pre>
						<code>
function draw() {
  var ctx = document.getElementById('canvas').getContext('2d');
  ctx.font = '48px serif';
  ctx.fillText('Hello world', 10, 50);
}</code>
					</pre>
					<aside class="notes">
						The canvas rendering context provides two methods to render text: fillText and strokeText.
					</aside>
				</section>
				<section>
					<h2>Styling text</h2>
					<ul>
						<li><span class="green">font = value</span> - The current text style being used when
							 drawing text. This string uses the same syntax as the CSS font property. The default font is 10px sans-serif.</li>
						<li><span class="green">textAlign = value</span> - Text alignment setting. Possible values: 
							start, end, left, right or center. The default value is start.</li>						
						<li><span class="green">direction = value</span> - Directionality. Possible values: ltr, rtl, inherit. The default value is inherit.</li>						
					</ul>
					<aside class="notes">
						In the example on the previous slide we are already making use of the font property to make the text a bit larger than the default size.
						There are some more properties which let you adjust the way the text gets displayed on the canvas, such as textAlign,
						direction and textBaseline.	-->
					</aside>					
				</section>
				<section>
					<ul>
						<li><span class="green">textBaseline = value</span> - Baseline alignment setting. Possible values: top,
								hanging, middle, alphabetic, ideographic, bottom. The default value is alphabetic.</li>
					</ul>
					<img src="images/baselines.png" alt="Baselines" >
					<aside class="notes">
						These properties might be familiar to you, if you have worked with CSS before.
						The following diagram demonstrates the various baselines supported by the textBaseline property.
					</aside>
				</section>
				<section>
					<h2>Transformations</h2>
					<h3>Saving and restoring state</h3>
					<ul>
						<li><span class="green">save()</span> - Saves the entire state of the canvas.</li>
						<li><span class="green">restore()</span> - Restores the most recently saved canvas state.</li>
					</ul>
					<h3>Translating</h3>
					<ul>
						<li><span class="green">translate(x, y)</span> - Moves the canvas and its origin on the grid. x indicates 
							the horizontal distance to move, and y indicates how far to move the grid vertically.</li>
					</ul>
					<aside class="notes">
						Before we look at the transformation methods, let's look at two other methods, such as save and restore. 
						Canvas states are stored on a stack. Every time the save() method is called, the current drawing state 
						is pushed into the stack.
						You can call the save() method as many times as you like. Each time the restore() method is called, 
						the last saved state is popped off the stack and all saved settings are restored.
						The first of the transformation methods we'll look at is translate(). This method is used to move 
						the canvas and its origin to a different point in the grid.
					</aside>
				</section>
				<section>
					<h3>Rotating</h3>
					<ul>
						<li><span class="green">rotate(angle)</span> - Rotates the canvas clockwise around the current origin by the angle number of radians.</li>
					</ul>	
					<img src="images/Canvas_grid_rotate.png" alt="Canvas grid rotate">
					<p>The rotation center point is always the canvas origin. To change the center point,
						 we will need to move the canvas by using the translate() method.</p>
					<aside class="notes">
						The second transformation method is rotate(). We use it to rotate the canvas around the current origin.
						The rotation center point is always the canvas origin. To change the center point, we will need to move
						 the canvas by using the translate() method.
					</aside>
				</section>
				<section>
					<h3>Scaling</h3>
					<ul>
						<li><span class="green">scale(x, y)</span> - Scales the canvas units by x horizontally and by y vertically.
							Both parameters are real numbers. Values that are smaller than 1.0 reduce the unit size and values above
							 1.0 increase the unit size. Values of 1.0 leave the units the same size.</li>
					</ul>					
					<aside class="notes">
						The next transformation method is scaling. We use it to increase or decrease the units in our canvas grid.						
					</aside>
				</section>
				<section>
					<h4>A scale example</h4>
					<pre>
						<code>
function draw() {
	var ctx = document.getElementById('canvas').getContext('2d');								
	// draw a simple rectangle, but scale it.
	ctx.save();
	ctx.scale(10, 3);
	ctx.fillRect(1, 10, 10, 10);
	ctx.restore();								  
	// mirror horizontally
	ctx.scale(-1, 1);
	ctx.font = '48px serif';
	ctx.fillText('MDN', -135, 120);
}</code>
					</pre>
					<img src="images/scale.png" alt="Scale">
					<aside class="notes">
						In this example, we'll draw shapes with different scaling factors.
					</aside>
				</section>
				<section>
					<h3>Transforms</h3>
					<ul>
						<li><span class="green">transform(a, b, c, d, e, f)</span> - Multiplies the current transformation matrix 
							with the matrix described by its arguments.</li>
						<li><span class="green">setTransform(a, b, c, d, e, f)</span> - Resets the current transform to the identity matrix,
							 and then invokes the transform() method with the same arguments.</li>
						<li><span class="green">resetTransform()</span> - Resets the current transform to the identity matrix.</li>
					</ul>
					<aside class="notes">
						Finally, the following transformation methods allow modifications directly to the transformation matrix.						
					</aside>
				</section>
				<section>
					<h2>Animations</h2>
					<h3>Basic animation steps</h3>
					<ol>
						<li>Clear the canvas</li>
						<li>Save the canvas state</li>
						<li>Draw animated shapes</li>
						<li>Restore the canvas state</li>
					</ol>
					<aside class="notes">
						Besides it's also very easy to make interactive animations with canvas.
						These are the steps you need to take to draw a frame...
					</aside>
				</section>
				<section>
					<h2>Controlling an animation</h2>
					<ul>
						<li><span class="green">setInterval(function, delay)</span> - Starts repeatedly executing the function specified by function every delay milliseconds.</li>
						<li><span class="green">setTimeout(function, delay)</span> - Executes the function specified by function in delay milliseconds.</li>
						<li><span class="green">requestAnimationFrame(callback)</span> - ells the browser that you wish to perform an animation and
							 requests that the browser call a specified function to update an animation before the next repaint.</li>
					</ul>
					<aside class="notes">
						Besides we need a way to execute our drawing functions over a period of time. There are two ways to control an animation like this.
						First there's the window.setInterval(), window.setTimeout(), and window.requestAnimationFrame() functions, which can be used to call
						a specific function over a set period of time.  The requestAnimationFrame method provides a smoother and more efficient way for 
						animating by calling the animation frame when the system is ready to paint the frame.						
					</aside>						
				</section>
				<section>
					<h4>Animation example</h4>
					<canvas id="canvas" width="500" height="500"></canvas>
					<script src="example.js"></script>
					<aside class="notes">
						This example animates a small model of our solar system.
						That's all I wanted to say today. Thanks you for attention.
					</aside>

				</section>
				
			</div>
		</div>

		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true }
				]
			});
		</script>
	</body>
</html>
